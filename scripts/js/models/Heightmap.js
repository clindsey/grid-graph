// Generated by CoffeeScript 1.4.0
(function() {

  define(["models/HeightmapChunk", "models/ViewportTile", "Alea", "Backbone"], function(HeightmapChunkModel, ViewportTileModel) {
    var Heightmap;
    Heightmap = Backbone.Model.extend({
      defaults: {
        SEED: (new Date()).getTime()
      },
      initialize: function() {
        var chunkHeight, chunkWidth, chunks, heightmap, maxElevation, worldChunkHeight, worldChunkWidth;
        worldChunkWidth = 8;
        worldChunkHeight = 8;
        chunkWidth = 9;
        chunkHeight = 9;
        maxElevation = 10;
        this.set({
          worldTileWidth: worldChunkWidth * chunkWidth,
          worldTileHeight: worldChunkHeight * chunkHeight
        });
        chunks = this.buildChunks(worldChunkWidth, worldChunkHeight, chunkWidth, chunkHeight, maxElevation);
        heightmap = this.generateHeightmap(chunks, worldChunkWidth * chunkWidth, worldChunkHeight * chunkHeight, chunkWidth, chunkHeight, maxElevation);
        return this.set("data", this.processTiles(heightmap));
      },
      processTiles: function(heightmap) {
        var a, b, c, cx, cy, d, data, e, f, g, h, n, ne, nw, o, s, se, sw, viewportTileModel, w, x, xl, y, yl, _i, _j, _ref, _ref1,
          _this = this;
        data = [];
        xl = this.get("worldTileWidth");
        yl = this.get("worldTileHeight");
        cx = function(x) {
          return _this.clamp(x, xl);
        };
        cy = function(y) {
          return _this.clamp(y, yl);
        };
        for (y = _i = 0, _ref = yl - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
          data[y] = [];
          for (x = _j = 0, _ref1 = xl - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            n = heightmap[cy(y - 1)][x];
            e = heightmap[y][cx(x + 1)];
            s = heightmap[cy(y + 1)][x];
            w = heightmap[y][cx(x - 1)];
            ne = heightmap[cy(y - 1)][cx(x + 1)];
            se = heightmap[cy(y + 1)][cx(x + 1)];
            sw = heightmap[cy(y + 1)][cx(x - 1)];
            nw = heightmap[cy(y - 1)][cx(x - 1)];
            o = heightmap[y][x];
            if (o === 0) {
              s = 0;
            } else {
              a = n << n * 8 - 4;
              b = e << e * 8 - 3;
              c = s << s * 8 - 2;
              d = w << w * 8 - 1;
              e = ne << ne * 8 - 8;
              f = se << se * 8 - 7;
              g = sw << sw * 8 - 6;
              h = nw << nw * 8 - 5;
              s = a + b + c + d + e + f + g + h;
            }
            viewportTileModel = new ViewportTileModel({
              type: s,
              x: x,
              y: y
            });
            data[y][x] = viewportTileModel;
          }
        }
        return data;
      },
      clamp: function(index, size) {
        return (index + size) % size;
      },
      generateHeightmap: function(chunks, worldTileWidth, worldTileHeight, chunkWidth, chunkHeight, maxElevation) {
        var cell, cellRow, cells, chunk, chunkRow, cx, cy, heightmap, x, xIndex, y, yIndex, _i, _j, _k, _l, _len, _len1, _len2, _len3;
        heightmap = [];
        for (y = _i = 0, _len = chunks.length; _i < _len; y = ++_i) {
          chunkRow = chunks[y];
          for (x = _j = 0, _len1 = chunkRow.length; _j < _len1; x = ++_j) {
            chunk = chunkRow[x];
            cells = chunk.get("cells");
            for (cy = _k = 0, _len2 = cells.length; _k < _len2; cy = ++_k) {
              cellRow = cells[cy];
              for (cx = _l = 0, _len3 = cellRow.length; _l < _len3; cx = ++_l) {
                cell = cellRow[cx];
                yIndex = cy + (y * cells.length);
                xIndex = cx + (x * cellRow.length);
                if (heightmap[yIndex] == null) {
                  heightmap[yIndex] = [];
                }
                heightmap[yIndex][xIndex] = this.tileHeightToType(cell, maxElevation);
              }
            }
          }
        }
        return heightmap;
      },
      tileHeightToType: function(height, maxElevation) {
        var type;
        if (height / maxElevation >= 0.5) {
          type = 1;
        } else {
          type = 0;
        }
        return type;
      },
      buildChunks: function(worldChunkWidth, worldChunkHeight, chunkWidth, chunkHeight, maxElevation) {
        var SEED, chunks, ne, nw, se, sw, worldTileWidth, x, y, _i, _j, _ref, _ref1;
        SEED = this.get("SEED");
        worldTileWidth = worldChunkWidth * chunkWidth;
        chunks = [];
        for (y = _i = 0, _ref = worldChunkHeight - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
          chunks[y] = [];
          for (x = _j = 0, _ref1 = worldChunkWidth - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            nw = (new Alea(y * worldTileWidth + x + SEED))() * maxElevation;
            if (x + 1 === worldChunkWidth) {
              ne = (new Alea(y * worldTileWidth + SEED))() * maxElevation;
            } else {
              ne = (new Alea(y * worldTileWidth + x + 1 + SEED))() * maxElevation;
            }
            if (y + 1 === worldChunkHeight) {
              sw = (new Alea(x + SEED))() * maxElevation;
              if (x + 1 === worldChunkWidth) {
                se = (new Alea(SEED)()) * maxElevation;
              } else {
                se = (new Alea(x + 1 + SEED))() * maxElevation;
              }
            } else {
              sw = (new Alea((y + 1) * worldTileWidth + x + SEED))() * maxElevation;
              if (x + 1 === worldChunkWidth) {
                se = (new Alea((y + 1) * worldTileWidth + SEED))() * maxElevation;
              } else {
                se = (new Alea((y + 1) * worldTileWidth + x + 1 + SEED))() * maxElevation;
              }
            }
            chunks[y][x] = new HeightmapChunkModel({
              ne: ne,
              nw: nw,
              se: se,
              sw: sw,
              width: chunkWidth,
              height: chunkHeight
            });
          }
        }
        return chunks;
      },
      getArea: function(sliceWidth, sliceHeight, centerX, centerY) {
        var dataHeight, dataOut, dataWidth, heightmapData, x, xIndex, xOffset, y, yIndex, yOffset, _i, _j, _ref, _ref1;
        dataOut = [];
        heightmapData = this.get("data");
        dataHeight = heightmapData.length;
        xOffset = sliceWidth >> 1;
        yOffset = sliceHeight >> 1;
        for (y = _i = 0, _ref = sliceHeight - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
          dataWidth = heightmapData[y].length;
          dataOut[y] = [];
          for (x = _j = 0, _ref1 = sliceWidth - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            xIndex = this.clamp(x - xOffset + centerX, dataWidth);
            yIndex = this.clamp(y - yOffset + centerY, dataHeight);
            dataOut[y][x] = heightmapData[yIndex][xIndex];
          }
        }
        return dataOut;
      }
    });
    return new Heightmap;
  });

}).call(this);
