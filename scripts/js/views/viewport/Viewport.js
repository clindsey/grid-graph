// Generated by CoffeeScript 1.4.0
(function() {

  define(["collections/ViewportTiles", "views/viewport/ViewportTile", "models/Viewport", "models/Heightmap", "collections/Creatures", "models/Creature", "views/entities/Creature", "AStar", "Backbone"], function(viewportTiles, ViewportTileView, viewportModel, heightmapModel, creatures, CreatureModel, CreatureView, AStar) {
    var ViewportView;
    return ViewportView = Backbone.View.extend({
      el: ".map-viewport",
      events: {
        "click": "onClick"
      },
      initialize: function() {
        _.bindAll(this, "onMapTileClick");
        this.render();
        return this.listenTo(viewportModel, "moved", this.onViewportMoved);
      },
      render: function() {
        var interval,
          _this = this;
        this.$el.css({
          width: viewportModel.get("width") * 16,
          height: viewportModel.get("height") * 16
        });
        this.grid = [];
        viewportTiles.each(function(mapTileModel) {
          var viewportTileView;
          viewportTileView = new ViewportTileView;
          viewportTileView.setModel(mapTileModel);
          _this.$el.append(viewportTileView.render().$el);
          viewportTileView.$el.click(function() {
            return _this.onMapTileClick(viewportTileView);
          });
          return _this.grid.push(viewportTileView);
        });
        interval = function(time, cb) {
          return setInterval(cb, time);
        };
        interval(1000 / 1, function() {
          return creatures.invoke("trigger", "tick");
        });
        return this;
      },
      onClick: function(jqEvent) {
        if (this.options.toolbarView.activeContext === "move") {
          return this.moveViewport(jqEvent);
        }
      },
      onMapTileClick: function(viewportTileView) {
        var context, creature, tileModel;
        tileModel = viewportTileView.model;
        context = this.options.toolbarView.activeContext;
        if (tileModel.get("isOccupied") === true && context !== "remove") {
          return;
        }
        if (tileModel.get("type") !== 255) {
          return;
        }
        switch (this.options.toolbarView.activeContext) {
          case "move":
            return "";
          case "road":
            return this.putRoad(tileModel);
          case "home":
            return this.putHome(tileModel);
          case "farm":
            return this.putFarm(tileModel);
          case "refinery":
            this.putRefinery(tileModel);
            return this.sendFirstWorker(tileModel);
          case "remove":
            if (tileModel.get("isOccupied")) {
              tileModel.removeOccupant();
              creature = tileModel.get("creature");
              if (creature != null) {
                creatures.remove(creature);
              }
              return this.informNeighbors(tileModel);
            }
        }
      },
      moveViewport: function(jqEvent) {
        var tileX, tileY, viewportHeight, viewportWidth, viewportX, viewportY, vx, vy;
        viewportWidth = viewportModel.get("width");
        viewportHeight = viewportModel.get("height");
        tileX = ~~(jqEvent.target.offsetLeft / 16);
        tileY = ~~(jqEvent.target.offsetTop / 16);
        vx = tileX - ~~(viewportWidth / 2);
        vy = tileY - ~~(viewportHeight / 2);
        viewportX = viewportModel.get("x");
        viewportY = viewportModel.get("y");
        return viewportModel.set({
          x: viewportX + vx,
          y: viewportY + vy
        });
      },
      onViewportMoved: function() {
        return _.each(this.grid, function(viewportTileView, index) {
          return viewportTileView.setModel(viewportTiles.at(index));
        });
      },
      putHome: function(tileModel) {
        var creature, creatureView, x, y;
        tileModel.set("buildingType", 1);
        this.informNeighbors(tileModel);
        x = tileModel.get("x");
        y = tileModel.get("y");
        creature = new CreatureModel({
          x: x,
          y: y
        });
        creatureView = new CreatureView({
          model: creature
        });
        creatures.add(creature);
        tileModel.set("creature", creature);
        return this.$el.append(creatureView.render().$el);
      },
      putFarm: function(tileModel) {
        tileModel.set("buildingType", 3);
        return this.informNeighbors(tileModel);
      },
      putRefinery: function(tileModel) {
        tileModel.set("buildingType", 2);
        return this.informNeighbors(tileModel);
      },
      putRoad: function(tileModel) {
        tileModel.set("roadType", 1);
        return this.informNeighbors(tileModel);
      },
      informNeighbors: function(tileModel) {
        var neighboringTiles, x, y;
        x = tileModel.get("x");
        y = tileModel.get("y");
        neighboringTiles = heightmapModel.getNeighboringTiles(x, y);
        return _.each(neighboringTiles, function(neighboringTile) {
          return neighboringTile.trigger("neighborChanged");
        });
      },
      sendFirstWorker: function(tileModel) {
        var deltaX, deltaY, end, grid, index, lastStep, path, pathOut, pathStep, start, targetX, targetY, unemployedCreature, worldHalfHeight, worldHalfWidth, worldTileHeight, worldTileWidth, x, y, _i, _len;
        x = tileModel.get("x");
        y = tileModel.get("y");
        worldTileWidth = heightmapModel.get("worldTileWidth");
        worldTileHeight = heightmapModel.get("worldTileHeight");
        grid = heightmapModel.getPathfindingGrid(worldTileWidth, worldTileHeight, x, y);
        unemployedCreature = creatures.first();
        worldHalfWidth = Math.ceil(worldTileWidth / 2);
        worldHalfHeight = Math.ceil(worldTileHeight / 2);
        deltaX = x - worldHalfWidth;
        deltaY = y - worldHalfHeight;
        targetX = heightmapModel.clampX(unemployedCreature.get("x") - deltaX);
        targetY = heightmapModel.clampY(unemployedCreature.get("y") - deltaY);
        start = [targetX, targetY];
        end = [worldHalfWidth, worldHalfHeight];
        path = AStar(grid, start, end);
        pathOut = [];
        for (index = _i = 0, _len = path.length; _i < _len; index = ++_i) {
          pathStep = path[index];
          if (index === 0) {
            continue;
          } else {
            lastStep = path[index - 1];
            pathOut.push([pathStep[0] - lastStep[0], pathStep[1] - lastStep[1]]);
          }
        }
        pathOut.push([0, 0]);
        return unemployedCreature.set("path", pathOut);
      }
    });
  });

}).call(this);
